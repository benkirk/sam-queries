name: SAM Database CI (Docker-only)

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  pytest:
    name: Run Test Suite (Docker)
    runs-on: ubuntu-latest

    steps:
      - name: Install MySQL Client
        run: |
          sudo apt-get install -y mysql-client

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      # currently needed for e.g. COPY --exclude syntax (1.19.0 / 2025-09-30)
      # https://docs.docker.com/build/buildkit/dockerfile-release-notes/?utm_source=chatgpt.com#1190
      - name: Install latest Docker
        uses: docker/setup-docker-action@v4
        with:
          docker-ce-version: latest   # or pin a version like "29.0.3"

      - name: Query Docker Environment
        run: |
          docker --version
          docker compose --version

      - name: Verify MySQL backup file exists and is not LFS pointer
        run: |
          BACKUP_FILE="containers/sam-sql-dev/backups/sam-obfuscated.sql.xz"
          
          if [ ! -f "${BACKUP_FILE}" ]; then
            echo "‚ùå Backup file not found: ${BACKUP_FILE}"
            echo "Please ensure backup is committed or use artifacts"
            exit 1
          fi
          
          echo "=== Backup file info ==="
          ls -lh "${BACKUP_FILE}"
          
          # Check if it's a Git LFS pointer (small file starting with "version https")
          FILE_SIZE=$(stat -c%s "${BACKUP_FILE}" 2>/dev/null || stat -f%z "${BACKUP_FILE}" 2>/dev/null)
          echo "File size: ${FILE_SIZE} bytes"
          
          if [ "${FILE_SIZE}" -lt 1000 ]; then
            echo "‚ö†Ô∏è File is very small, checking if it's an LFS pointer..."
            head -c 100 "${BACKUP_FILE}" | cat -v
            if head -c 50 "${BACKUP_FILE}" | grep -q "version https"; then
              echo ""
              echo "‚ùå File is a Git LFS pointer, not the actual backup!"
              echo "Attempting to pull LFS files..."
              git lfs pull
              ls -lh "${BACKUP_FILE}"
            fi
          else
            echo "‚úÖ Backup file appears to be actual data (${FILE_SIZE} bytes)"
          fi
          
          # Verify it's a valid xz file
          echo ""
          echo "=== Verifying xz format ==="
          if file "${BACKUP_FILE}" | grep -q "XZ compressed"; then
            echo "‚úÖ File is valid XZ compressed data"
          else
            echo "‚ö†Ô∏è File type:"
            file "${BACKUP_FILE}"
          fi

      - name: Build and start services
        run: |
          docker compose build
          docker compose up -d
          # Show immediate status
          docker compose ps
          sleep 5
          docker compose ps

      - name: Show MySQL container status and logs
        run: |
          echo "=== Container status ==="
          docker compose ps -a
          
          echo ""
          echo "=== MySQL container logs ==="
          docker compose logs mysql --tail=100 || true
          
          echo ""
          echo "=== Check if MySQL is running ==="
          docker compose ps mysql --format "{{.State}}" || echo "Could not get state"

      - name: Wait for services to be healthy
        run: |
          echo "=== Waiting for MySQL to be healthy ==="
          
          # First check if MySQL container is even running
          MYSQL_STATE=$(docker compose ps mysql --format "{{.State}}" 2>/dev/null || echo "unknown")
          echo "MySQL container state: ${MYSQL_STATE}"
          
          if [ "${MYSQL_STATE}" = "exited" ]; then
            echo "‚ùå MySQL container has exited! Showing logs..."
            docker compose logs mysql --tail=200
            exit 1
          fi
          
          # Wait for MySQL to be ready
          echo "Waiting for MySQL to accept connections..."
          for i in $(seq 1 36); do
            if docker compose exec -T mysql mysqladmin ping -h localhost -u root -proot --silent 2>/dev/null; then
              echo "‚úÖ MySQL is healthy after $((i * 5)) seconds"
              break
            fi
            
            # Check if container is still running
            STATE=$(docker compose ps mysql --format "{{.State}}" 2>/dev/null || echo "unknown")
            if [ "${STATE}" = "exited" ]; then
              echo "‚ùå MySQL container exited while waiting!"
              docker compose logs mysql --tail=200
              exit 1
            fi
            
            echo "  Waiting... ($i/36, state: ${STATE})"
            sleep 5
          done
          
          # Verify MySQL is actually ready
          docker compose exec -T mysql mysqladmin ping -h localhost -u root -proot || {
            echo "‚ùå MySQL health check failed!"
            docker compose logs mysql --tail=100
            exit 1
          }
          echo "‚úÖ MySQL is healthy"

          echo ""
          echo "=== Waiting for webapp to be ready ==="
          timeout 60 bash -c 'until docker compose exec -T webapp python -c "import sys; sys.exit(0)" 2>/dev/null; do sleep 2; done'
          echo "‚úÖ Webapp is ready"

      - name: Show container logs (for debugging)
        if: failure()
        run: |
          docker compose logs --tail=200

      - name: Show MySQL databases
        run: |
          mysql -h 127.0.0.1 -proot -uroot system_status --table -e "SHOW tables;"
          mysql -h 127.0.0.1 -proot -uroot sam --table -e "SHOW tables;"
          mysql -h 127.0.0.1 -proot -uroot sam --table -e "SELECT * from tables_dictionary;"

      - name: Run pytest with coverage
        id: pytest
        run: |
          docker compose exec -T webapp bash -c "cd /code && pytest tests/ --cov=src --cov-report=term-missing --cov-report=html --cov-fail-under=70"

      - name: Copy coverage report from container
        if: always()
        run: |
          docker compose cp webapp:/code/htmlcov ./htmlcov || echo "No coverage report generated"

      - name: Upload coverage HTML report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report-html
          path: htmlcov/
          retention-days: 30

      - name: Display coverage summary
        if: always()
        run: |
          echo "üìä Coverage report available in GitHub Actions artifacts"
          echo "Download 'coverage-report-html' to view detailed line-by-line coverage"
          echo ""
          echo "‚ÑπÔ∏è  Coverage threshold: 80% minimum required"
          if [ "${{ steps.pytest.outcome }}" == "failure" ]; then
            echo "‚ùå Coverage threshold not met or tests failed"
          else
            echo "‚úÖ Coverage threshold met and all tests passed"
          fi

      - name: Cleanup
        if: always()
        run: |
          docker compose down -v
