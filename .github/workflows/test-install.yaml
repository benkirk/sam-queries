name: Test Install Script

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: ${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  test-piped-install:
    runs-on: ubuntu-latest
    steps:
      - name: Install MySQL Client
        run: sudo apt-get install -y mysql-client

      - name: Setup Environment
        run: echo "INSTALL_DIR=${{ runner.temp }}/test-install-target" >> ${GITHUB_ENV}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      # Ensure latest Docker for compatibility
      - name: Install latest Docker
        uses: docker/setup-docker-action@v4
        with:
          docker-ce-version: latest

      - name: Test "curl | bash" style installation
        run: |
          # ---------------------------------------------------------
          # Determine Repo and Branch to test
          # ---------------------------------------------------------
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            # For PRs, use the head repo url (handles forks)
            TARGET_REPO="${{ github.event.pull_request.head.repo.clone_url }}"
            TARGET_BRANCH="${{ github.head_ref }}"
          else
            # For pushes, use the current repository
            TARGET_REPO="${{ github.server_url }}/${{ github.repository }}"
            TARGET_BRANCH="${{ github.ref_name }}"
          fi

          echo "Testing install logic with:"
          echo "  Repo:   ${TARGET_REPO}"
          echo "  Branch: ${TARGET_BRANCH}"

          # ---------------------------------------------------------
          # Execute Install Script
          # ---------------------------------------------------------
          # Simulate remote execution by piping the local script file.
          # We pass arguments to verify the script correctly handles them
          # and to point it to the code version corresponding to this CI run.
          cat install.sh | bash -s -- \
            --dir "${INSTALL_DIR}" \
            --repo "${TARGET_REPO}" \
            --branch "${TARGET_BRANCH}"

          # ---------------------------------------------------------
          # Verify Results
          # ---------------------------------------------------------
          echo "--- Verifying Installation ---"
          if [[ ! -d "${INSTALL_DIR}" ]]; then
             echo "::error::Installation directory was not created."
             exit 1
          fi

          if [[ ! -d "${INSTALL_DIR}/.git" ]]; then
             echo "::error::Git repository not initialized in target."
             exit 1
          fi

          if [[ ! -f "${INSTALL_DIR}/compose.yaml" ]]; then
             echo "::error::compose.yaml missing in install dir."
             exit 1
          fi

          if [[ ! -f "${INSTALL_DIR}/.env" ]]; then
             echo "::error::.env file was not created (setup step failed)."
             exit 1
          fi

          echo "✅ Installation verified successfully at ${INSTALL_DIR}"

      - name: Verify backup file
        run: |
          cd "${INSTALL_DIR}"
          BACKUP_FILE="containers/sam-sql-dev/backups/sam-obfuscated.sql.xz"
          
          echo "=== Verifying backup file ==="
          ls -lh "${BACKUP_FILE}" || echo "Backup file not found"
          
          FILE_SIZE=$(stat -c%s "${BACKUP_FILE}" 2>/dev/null || stat -f%z "${BACKUP_FILE}" 2>/dev/null || echo "0")
          echo "File size: ${FILE_SIZE} bytes"
          
          if [ "${FILE_SIZE}" -lt 1000 ]; then
            echo "⚠️ File appears to be LFS pointer, pulling..."
            git lfs pull
            ls -lh "${BACKUP_FILE}"
          fi

      - name: Start Services
        run: |
          cd "${INSTALL_DIR}"
          echo "Starting services in ${INSTALL_DIR}..."
          docker compose build
          docker compose up -d
          
          echo "=== Initial container status ==="
          docker compose ps -a
          sleep 5
          docker compose ps -a

      - name: Wait for MySQL to be healthy (TCP from host)
        run: |
          cd "${INSTALL_DIR}"

          echo "=== Waiting for MySQL to accept TCP connections on 127.0.0.1:3306 ==="
          
          # Wait using HOST mysql client over TCP — same path as subsequent steps.
          for i in $(seq 1 60); do
            if mysql -h 127.0.0.1 -proot -uroot -e "SELECT 1" 2>/dev/null; then
              echo "✅ MySQL accepting TCP connections after $((i * 5))s"
              break
            fi
            
            STATE=$(docker compose ps mysql --format "{{.State}}" 2>/dev/null || echo "unknown")
            if [ "${STATE}" = "exited" ]; then
              echo "❌ MySQL container exited!"
              docker compose logs mysql --tail=200
              exit 1
            fi
            
            if [ $((i % 6)) -eq 0 ]; then
              echo "  Still waiting... ($((i * 5))s elapsed, container state: ${STATE})"
            fi
            sleep 5
          done
          
          # Verify sam database is queryable
          echo ""
          echo "=== Verifying sam database ==="
          for i in $(seq 1 12); do
            if mysql -h 127.0.0.1 -proot -uroot sam -e "SELECT 1" 2>/dev/null; then
              echo "✅ SAM database is ready"
              break
            fi
            echo "  Waiting for sam database... ($((i * 5))s)"
            sleep 5
          done
          
          mysql -h 127.0.0.1 -proot -uroot sam -e "SELECT 1" || {
            echo "❌ SAM database not accessible!"
            docker compose logs mysql --tail=100
            exit 1
          }

      - name: Wait for webapp to be ready
        run: |
          cd "${INSTALL_DIR}"
          timeout 60 bash -c 'until docker compose exec -T webapp python -c "import sam; import sys; sys.exit(0)" 2>/dev/null; do sleep 2; done'
          echo "✅ Webapp is ready"

      - name: Show running containers
        run: |
          cd "${INSTALL_DIR}"
          docker compose ps

      - name: Run pytest in parallel without coverage
        id: pytest
        run: |
          cd "${INSTALL_DIR}"
          docker compose exec -T webapp bash -c "cd /code && pytest tests/ -n auto"

      - name: Show container logs (on failure)
        if: failure()
        run: |
          if [ -d "${INSTALL_DIR}" ]; then
            cd "${INSTALL_DIR}"
            docker compose logs --tail=300
          fi

      - name: Cleanup
        if: always()
        run: |
          if [ -d "${INSTALL_DIR}" ]; then
            cd "${INSTALL_DIR}"
            docker compose logs --tail=300
            docker compose down -v
          fi
